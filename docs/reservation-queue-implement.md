# 동시성 제어 - 예약 대기열 구현

## 문제 상황

- 잔여 예약석에 관한 이전의 동시성 제어 방식에서는 DB 비관적 락에만 의존했기 때문에 DB에 가해지는 부하가 증가하면서 아래의 문제가 발생
  - 예약 요청 시, DB 커넥션을 확보한 상태에서 DB 비관적 락을 걸고 DB 트랜잭션에 진입하는 구조
  - 위 상황에서, 동시에 들어온 예약 요청 수가 크게 증가(수백 ~ 수천 건)할 경우 DB 커넥션이 고갈되어 DeadLock이 발생
    - 'Pool-Locking (DB 커넥션 고갈 데드락)' 현상: 트랜잭션 내부에서 외부 리소스(락)를 대기하면, DB 커넥션을 점유한 채로 멈춰버리면서 발생하는 Deadlock
- 따라서, 다음의 문제를 개선하기 위해 애플리케이션 게층에 예약 대기열을 추가
  - 동시에 발생한 예약 요청을 처리할 때 DB 커넥션이 고갈되는 것을 방지
  - 동시 예약 요청 발생 시 DB에 가해지는 부하를 줄여 예약 폭주로 인해 서버가 중단되는 것을 방지

## 목표

- Redisson을 활용한 예약 대기열 구현을 통해 다음의 목표를 달성하는 것
    - DB 커넥션 고갈로 인해 Deadlock이 발생하게 되는 문제 방지
    - 특정 식당의 특정 시간대에 예약이 몰리는 상황을 공정하게 처리

## 구현 방향 설정
- 사용할 수 있는 서버의 디스크 용량이 부족했던 반면, 메모리 용량은 상대적으로 충분
  - 서버의 메모리를 효율적으로 활용하고 DB의 부하를 줄이기 위해 위해 Redis를 사용
- Redis 기반의 Java 라이브러리인 Redisson을 활용하는 방향으로 진행
  - 예약 대기열을 설정한 목적은 특정 식당의 특정 시간대에 예약이 몰리는 상황을 통제하는 것
  - 예약 신청을 하기 위한 기본 정보(예약 날짜, 시간, 인원, 주문할 메뉴 등)를 입력한 다음 바로 결제 단계로 진입해야 함.
    - 사용자가 버튼을 누르고 3~5초 이내에 즉각적인 성공/실패 피드백을 받는 것이 UX 적으로 더 중요
    - 예약 기능이므로 선착순으로 접수할 수 있어야 하기 때문에 일반 락 대신 FairLock을 사용
    - 구현 복잡도를 낮추고 즉시성을 보장하기 위해, Redis FairLock을 이용한 동기식 대기열(Blocking Queue) 모델을 채택

## 구현

### 예약 대기열의 기본 동작 방식(백엔드)

- 예약 대기열 관련 기능은 Redis 관련 라이브러리 중 Redisson을 활용
  - Redisson 라이브러리에서는 FairLock 등 예약 대기열 구현에 필요한 기능들을 제공
  - 구현한 코드에서 사용한 getFairLock 메서드는 RedissonFairLock을 반환
    - RedissonFairLock의 내부 로직은 Queue와 유사한 메커니즘으로 동작
